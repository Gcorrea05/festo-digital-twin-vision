üìå Explica√ß√£o das rotas e funcionamento do sistema
1. Estrutura geral

O backend foi feito em FastAPI (Python) e exp√µe rotas HTTP e WebSocket.
O frontend (React + Vite/TSX) consome essas rotas para exibir em tempo real ou ‚Äúreplay‚Äù os dados dos sensores.

As tabelas envolvidas:

opc_samples ‚Üí vari√°veis OPC (fins de curso, sinais digitais etc.)

mpu_samples ‚Üí dados dos aceler√¥metros MPU (vibra√ß√£o)

INICIA e PARA ‚Üí sinais OPC usados para calcular ciclos por minuto (CPM)

2. Rotas principais
Healthcheck
GET /health


Retorna {"status": "ok", "db_time": ...}

Usado para verificar se API e banco est√£o respondendo.

OPC ‚Äì √öltima amostra
GET /opc/latest?name=<sinal>


Exemplo: /opc/latest?name=Recuado_1S1

Retorna a √∫ltima linha da tabela opc_samples para o sinal informado.

Exemplo de resposta:

{
  "ts_utc": "2025-09-05T23:11:40Z",
  "name": "Recuado_1S1",
  "value_bool": true
}

OPC ‚Äì Hist√≥rico
GET /opc/history?name=<sinal>&limit=20000&asc=true&since=-1d


Retorna v√°rias amostras ordenadas no tempo.

name = nome do sinal OPC (ex.: Recuado_1S1, Avancado_1S2, INICIA, PARA)

limit = quantidade m√°xima de pontos (normalmente 20.000)

asc=true = ordena√ß√£o crescente no tempo

since = intervalo relativo (ex.: -1d = √∫ltimo dia)

Exemplo de item:

{
  "ts_utc": "2025-09-05T23:11:40Z",
  "value_bool": 0
}

MPU ‚Äì √öltima amostra
GET /mpu/latest?id=MPUA1


Retorna o √∫ltimo registro de vibra√ß√£o de um aceler√¥metro espec√≠fico.

Exemplo:

{
  "ts_utc": "2025-09-05T23:11:40Z",
  "id": "MPUA1",
  "ax_g": 0.012,
  "ay_g": -0.004,
  "az_g": 0.998,
  "gx_dps": 0.1,
  "gy_dps": 0.0,
  "gz_dps": 0.2,
  "temp_c": 28.3
}

MPU ‚Äì Hist√≥rico
GET /mpu/history?id=MPUA1&limit=20000&asc=true&since=-1d


Retorna uma lista de amostras de vibra√ß√£o (acelera√ß√£o X/Y/Z em ‚Äúg‚Äù).

Usado para calcular RMS de vibra√ß√£o ao longo do tempo.

3. L√≥gica no Frontend

O frontend n√£o faz requisi√ß√µes a cada 2s.
üëâ Ele baixa todo o hist√≥rico de uma vez (limit=20000 pontos) e depois roda um ‚Äúplayer‚Äù que avan√ßa o √≠ndice (idx) a cada 2 segundos.

No LiveMetrics.tsx, a l√≥gica funciona assim:

Status atual
Calculado a partir das combina√ß√µes de fins de curso:

(recuado=1, avancado=0) ‚Üí fechado

(recuado=0, avancado=1) ‚Üí aberto

(1,1) ‚Üí erro

(0,0) ‚Üí indef
Resultado mostrado como:

A1:aberto | A2:fechado


Vibration
Pega janela de 50 amostras do MPU e calcula RMS nas tr√™s dire√ß√µes.
Exemplo exibido:

0.619 g


CPM (Cycles Per Minute)
A partir dos sinais INICIA e PARA, o frontend detecta bordas de subida (transi√ß√µes 0‚Üí1).
Cada par de eventos conta como um ciclo.
√â feito c√°lculo na janela de 200 amostras para estimar ciclos/minuto.
Exemplo exibido:

12.30 cpm

4. Resumindo o fluxo

Backend FastAPI fornece rotas /opc/... e /mpu/... ‚Üí pega do MySQL.

Frontend chama cada rota s√≥ 1 vez para baixar o hist√≥rico.

Um player interno (setInterval) avan√ßa o √≠ndice a cada 2s.

Os valores de Status atual, Vibration e CPM s√£o recalculados e exibidos a cada frame.

üìå Benef√≠cios dessa abordagem

Evita sobrecarregar o backend com requisi√ß√µes a cada 2s.

Permite replay hist√≥rico (n√£o s√≥ live).

Mant√©m a l√≥gica id√™ntica ao prot√≥tipo em test.html, mas integrada ao React.